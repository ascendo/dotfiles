#!/bin/sh

# This script is meant to be run from cron. It:
#   - finds torrents under a directory (including its subdirectories) and
#     adds them to transmission, specifying the directory from where the
#     torrent was located to be the completed directory for the data
#   - deselects sample files
#   - throttles public torrents
#   - removes completed, stopped torrents
#   - verifies RAR archives with cksfv
#   - unrars RAR archives
#   - removes RAR archives after torrent has been removed
#
# TODO:
#   - remove certain trackers (when support for this is added to remote)
#   - use getopts to accept command-line options
#   - kill transmission if it's hanging so it can be restarted by some
#     external process (launchd, inetd, etc.)

VERBOSE=1
LOCK=/tmp/transmission-watchdog.lock
NETRC=~/.netrc
WATCH_DIR=~/Media/.
PUBLIC_UP_RATE=2
PUBLIC_RATIO=0

set -o errexit
set -o nounset

IFS=$(printf "\n\t")

has_cmd () { command -v "$@" >/dev/null 2>&1; }
warn    () { printf "$@" >&2; }

if has_cmd flock; then
    flock -nx "$LOCK" || exit
elif has_cmd shlock; then
    trap 'rm -f "$LOCK"; exit' HUP INT QUIT TERM
    shlock -f "$LOCK" -p $$ || exit
    trap 'rm -f "$LOCK"; exit' EXIT
elif has_cmd lockfile; then
    trap 'rm -f "$LOCK"; exit' HUP INT QUIT TERM
    lockfile -r 0 -l 300 "$LOCK" >/dev/null 2>&1 || exit
    trap 'rm -f "$LOCK"; exit' EXIT
else
    ln -s /dev/null "$LOCK" 2>/dev/null || exit
    trap 'rm -f "$LOCK"; exit' EXIT HUP INT QUIT TERM
fi

timeout () {
    timeout=$1
    shift
    "$@" &
    child_pid=$!
    (
        sleep "$timeout" &
        sleep_pid=$!
        trap 'kill -s TERM $sleep_pid 2>/dev/null; exit 0' TERM
        wait $sleep_pid 2>/dev/null
        kill -s TERM $child_pid 2>/dev/null
        sleep 2
        kill -s KILL $child_pid 2>/dev/null
    ) &
    alarm_pid=$!
    wait $child_pid 2>/dev/null
    status=$?
    kill -s TERM $alarm_pid 2>/dev/null
    return $status
}

remote () {
    # TODO: add retry and kill logic
    timeout 30 transmission-remote -N $NETRC "$@"
}

# Add any new torrent files to transmission.
for file in $(find "$WATCH_DIR" -type f -name '*.torrent' 2>/dev/null); do
    dir=${file%/*}

    # Parse the debug output.
    # Use the torrent hash because the ids are not persistent across sessions.
    response=$(
        remote --debug --add "$file" --download-dir "$dir" 2>&1 | \
        awk '/^{"arguments":{.*?"result":/ {x=$0}; END{print x}'
    )

    hash=$(
        echo $response | \
        awk -F'"' '/^{"arguments":{"torrent-added":/{print$8;exit}'
    )
    if [ -z "$hash" ]; then
        warn "Failed to add torrent: $file\n"
        mv -f "$file" "$file.failed"
        continue
    elif echo $response | grep '"result":"duplicate torrent"' >/dev/null 2>&1
    then
        warn "Skipping already added torrent: $file\n"
        rm -f "$file"
        continue
    else
        rm -f "$file"
    fi

    [ 1 = "$VERBOSE" ] && printf "Added torrent ${file##*/}: ${hash}\n"

    ids=$(
        remote --torrent "$hash" --files | \
        sed -n 's/^ *\([0-9]\{1,\}\):.*\/[Ss][Aa][Mm][Pp][Ll][Ee]\/.*/\1/p' | \
        paste -d ',' -s -
    )
    [ "$ids" ] && remote --torrent "$hash" --no-get "$ids" >/dev/null
done

real_dir () {
    real_dir=
    cd -P -- "$1" && _real_dir="$(pwd -P)"
}

real_dir "$WATCH_DIR" && WATCH_DIR="$_real_dir"

has_cmd unrar && HAS_UNRAR=1 || HAS_UNRAR=0
has_cmd cksfv && HAS_CKSFV=1 || HAS_CKSFV=0

do=0
for line in $(remote --torrent all --info); do
    val=${line##*: }
    case "$line" in
        '  Hash: '?*)            hash=$val      ;;
        '  Name: '?*)            name=$val      ;;
        '  State: '?*)           state=$val     ;;
        '  Location: '?*)        dir=$val       ;;
        '  Percent Done: '?*)    percent=$val   ;;
        '  Date finished: '?*)   finished=$val  ;;
        '  Date started: '?*)    started=$val   ;;
        '  Public torrent: '?*)  public=$val    ;;
        '  Upload Limit: '?*)    up_rate=$val
                                 do=1           ;;
    esac

    [ 1 != "$do" ] && continue

    case "$state" in
        Verifying*) continue ;;
    esac

    if [ Yes = "$public" ] && [ "$PUBLIC_UP_RATE" != "${up_rate%%[. ]*}" ]
    then
        remote --torrent "$hash" --uplimit "$PUBLIC_UP_RATE" \
            --seedratio "$PUBLIC_RATIO" >/dev/null
        [ 1 = "$VERBOSE" ] && printf "Throttled public torrent: $name\n"
        [ '100%' = "$percent" ] && state=Finished
    fi

    [ '100%' != "$percent" ] && continue

    do=; last_dir=; unrarred_lock=

    if [ 1 = "$HAS_UNRAR" ]; then
        # Verify directory is valid and in expected location.
        real_dir "$dir" >/dev/null 2>&1 && dir="$_real_dir"
        case $dir in
            $WATCH_DIR) ;; $WATCH_DIR/*) ;; *) continue ;;
        esac

        for file in $(find "$dir/$name" -type f -name '*.rar' 2>/dev/null)
        do
            rar_dir=${file%/*}
            rar_file=${file##*/}
            [ "$rar_dir" = "$last_dir" ] && continue
            last_dir=$rar_dir
            unrarred_lock=$rar_dir/.$rar_file.unrarred
            [ -e "$unrarred_lock" ] && continue

            sfv_file=${rar_file%.*}.sfv
            if [ 1 = "$HAS_CKSFV" ] && [ -e "$rar_dir/$sfv_file" ]; then
                if ! nice -n 15 cksfv -qg "$rar_dir/$sfv_file"; then
                    touch "$unrarred_lock"
                    if [ 1 = "$VERBOSE" ]; then
                        warn "Invalid RAR: ${rar_dir##$WATCH_DIR/}/$rar_file\n"
                    fi
                    continue
                fi
            fi

            touch "$unrarred_lock"

            if ! nice -n 15 unrar x -inul -y -p- -o+ -r \
                "$rar_dir/$rar_file" "$rar_dir"
            then
                warn "Unable to extract RAR: ${rar_dir##$WATCH_DIR/}/$rar_file\n"
                continue
            fi

            if [ 1 = "$VERBOSE" ]; then
                printf "Unrarred %s/%s\n" "${rar_dir##$WATCH_DIR/}" "$rar_file"
            fi
        done
    fi

    if [ Finished = "$state" ]; then
        remote --torrent "$hash" --remove >/dev/null
        [ 1 = "$VERBOSE" ] && printf "Removed torrent: $name\n"

        if [ "$unrarred_lock" ]; then
            if [ -d "$dir/$name" ]; then
                ! find "$dir/$name" -type f \( -name '*.rar' -o    \
                    -name '*.r[0-9]' -o -name '*.r[0-9][0-9]' -o   \
                    -name '*.r[0-9][0-9][0-9]' -o -name '*.sfv' -o \
                    -name '*.[Nn][Ff][Oo]' -o -name '.DS_Store' -o \
                    -name '*.part' -o -name '.*.unrarred' -o       \
                    -name 'www.TorrentDay.com.txt' -o              \
                    -name '.message' \)                            \
                    -exec rm -f {} \; 2>/dev/null
                ! find "$dir/$name/" -type d -depth                \
                    -name [Ss][Aa][Mm][Pp][Ll][Ee]                 \
                    -exec rm -rf {} \; 2>/dev/null
                ! find "$dir/$name" -type d -depth                 \
                    -exec rmdir {} \; 2>/dev/null
            elif [ -f "$dir/$name" ]; then
                [ rar = "${file##*.}" ] && rm -f "$dir/$name"
                rm -f "$unrarred_lock"
            fi
            [ 1 = "$VERBOSE" ] && printf "Removed RAR archive: $name\n"
        fi
    fi
done
