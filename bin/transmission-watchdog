#!/bin/sh

# This script is meant to be run from cron. It:
#   - finds torrents under a directory (including its subdirectories) and
#     adds them to transmission, specifying the directory from where the
#     torrent was located to be the completed directory for the data
#   - deselects sample files
#   - throttles public torrents
#   - removes certain "bad" trackers from torrents
#   - labels files of seeding torrents
#   - removes completed, stopped torrents
#   - verifies RAR archives with cksfv
#   - unrars RAR archives
#   - removes RAR archives after torrent has been removed
#
# TODO:
#   - handle multiple rar archives in the same directory
#   - use getopts to accept command-line options
#   - kill transmission if it's hanging so it can be restarted by some
#     external process (launchd, inetd, etc.)

LOCK=/tmp/transmission-watchdog.lock
NETRC=$HOME/.netrc
WATCH_DIR=$HOME/Media/.
PUBLIC_UP_RATE=2
PUBLIC_RATIO=0

set -o errexit
set -o nounset

IFS=$(printf "\n\t")

has_cmd () { command -v "$@" >/dev/null 2>&1; }

if has_cmd flock; then
    flock -nx "$LOCK" || exit
else
    trap 'status=$?; rm -f "$LOCK"; exit $status' HUP INT QUIT TERM
    if has_cmd shlock; then
        shlock -f "$LOCK" -p $$ || exit
    elif has_cmd lockfile; then
        lockfile -r 0 -l 300 "$LOCK" >/dev/null 2>&1 || exit
    else
        ln -s /dev/null "$LOCK" 2>/dev/null || exit
    fi
    trap 'rm -f "$LOCK"; exit' EXIT
fi

if   has_cmd timeout; then :
elif has_cmd gtimeout; then timeout () { gtimeout "$@"; }
else
    timeout () {
        timeout=$1
        shift
        "$@" &
        child_pid=$!
        (
            sleep "$timeout" &
            sleep_pid=$!
            trap 'kill -s TERM $sleep_pid 2>/dev/null; exit 0' TERM
            wait $sleep_pid 2>/dev/null
            kill -s TERM $child_pid 2>/dev/null
            sleep 2
            kill -s KILL $child_pid 2>/dev/null
        ) &
        alarm_pid=$!
        wait $child_pid 2>/dev/null
        status=$?
        kill -s TERM $alarm_pid 2>/dev/null
        return $status
    }
fi

log  () { printf "[$(date +%F\ %T)] $@"; }
warn () { log "$@" >&2; }

remote () {
    # TODO: add retry and kill logic
    exec 3>&1 4>&2
    if ! error=$(
        { timeout 30 transmission-remote -N $NETRC "$@" 2>&4 1>&3; } 4>&1
    ); then
        case $error in
            *"Couldn't connect to server")
                warn "$error\n"
                exit 1
        esac
    fi
    exec 3>&- 4>&-
    printf "$error" >&2
}

real_dir () {
    _real_dir=
    cd -P -- "$1" 2>/dev/null && _real_dir=$(pwd -P)
}

real_dir "$WATCH_DIR" && WATCH_DIR=$_real_dir || {
    warn 'WATCH_DIR directory "%s" does not exist\n' "$WATCH_DIR"
    exit -1
}

# Add any new torrent files to transmission.
for file in $(
    find "$WATCH_DIR" -type f -name '*.torrent' \! -size 0 2>/dev/null
)
do
    dir=${file%/*}

    # Parse the debug output.
    # Use the torrent hash because the ids are not persistent across sessions.
    result=
    response=$(remote --debug --add "$file" --download-dir "$dir" 2>&1)
    for line in $response; do
        case $line in '{"arguments":{'*'"result":'*) result=$line; esac
    done

    case $result in
        '') continue ;;
        '{"arguments":{"torrent-added":{"hashString":'*)
            SAVED_IFS=$IFS; IFS='"'; set -- $result; IFS=$SAVED_IFS
            hash=$8;
            rm -f "$file" ;;
        '{"arguments":{},"result":"duplicate torrent"'*)
            warn "Skipping already added torrent: $file\n"
            rm -f "$file"
            continue ;;
        *)
            warn "Failed to add torrent: $file\n"
            mv -f "$file" "$file.failed"
            continue
    esac

    for line in $(remote --torrent "$hash" --info); do
        case $line in
            '  Public torrent: '?*) public=${line#*: } ;;
            '  Name: '?*)           name=${line#*: }
        esac
    done

    log "Added torrent: $name\n"

    # Deselect sample files and subs for tv series.
    ids=; count=0
    for line in $(remote --torrent "$hash" --files); do
        # Skip header lines
        [ $count -lt 2 ] && count=$((count+1)) && continue
        deselect=
        case $line in
            *[/.\ ][Ss][Aa][Mm][Pp][Ll][Ee].avi) deselect=1 ;;
            */[Ss][Aa][Mm][Pp][Ll][Ee]/*)        deselect=1 ;;
            */[Ss][Uu][Bb][Ss]/*)
                case $dir/ in "$WATCH_DIR"/TV/*) deselect=1; esac
        esac
        if [ "$deselect" ]; then
            SAVED_IFS=$IFS; IFS=': '; set -- $line; IFS=$SAVED_IFS
            [ "$ids" ] && ids=$ids,$1 || ids=$1
        fi
    done
    [ "$ids" ] && remote --torrent "$hash" --no-get "$ids" >/dev/null

    for line in $(remote --torrent "$hash" --info-trackers); do
        SAVED_IFS=$IFS; IFS=' :/'; set -- $line; IFS=$SAVED_IFS
        [ 6 -le $# ] && [ Tracker = $1 ] || continue
        id=$2 tracker=$6
        case $id in '' | *[!0-9]*) continue; esac
        case $tracker in
            tracker.openbittorrent.com | \
            tracker.publicbt.*         | \
            inferno.demonoid.*         | \
            *.prq.to                   | \
            *.h33t.com                 | \
            *.1337x.org                | \
            www.mvgroup.org)
                force_public=1 ;;
            *.hexagon.cc               | \
            *.thepiratebay.org         | \
            *.onion                    | \
            *.tor2web.com)
                remote --torrent "$hash" --tracker-remove "$id" >/dev/null
        esac
    done

    # Throttle public torrents.
    if [ Yes = "$public" ] || [ 1 = "${force_public:-0}" ]; then
        remote --torrent "$hash" --uplimit "$PUBLIC_UP_RATE" \
            --seedratio "$PUBLIC_RATIO" >/dev/null
        log "Throttled public torrent: $name\n"
    fi
done

has_cmd unrar    && HAS_UNRAR=1    || HAS_UNRAR=0
has_cmd cksfv    && HAS_CKSFV=1    || HAS_CKSFV=0
has_cmd setlabel && HAS_SETLABEL=1 || HAS_SETLABEl=0

for line in $(remote --torrent all --info); do
    val=${line#*: }
    case $line in
        '  Name: '?*)         name=$val    ;;
        '  Hash: '?*)         hash=$val    ;;
        '  State: '?*)        state=$val   ;;
        '  Location: '?*)     dir=$val     ;;
        '  Percent Done: '?*) percent=$val
                              do=1
    esac

    [ 1 != "${do-0}" ]       && continue
    [ '100%' != "$percent" ] && continue

    case $state in
        Verifying*) continue
    esac

    do=0; last_dir=; unrarred_lock=

    # Verify directory is valid and in expected location.
    real_dir "$dir" && dir=$_real_dir || dir=
    case $dir/ in $WATCH_DIR/*) ;; *) continue; esac

    while [ 1 = "$HAS_UNRAR" ]; do
        for file in $(find "$dir/$name" -type f -name '*.rar' 2>/dev/null)
        do
            rar_dir=${file%/*}
            rar_file=${file##*/}
            [ "$rar_dir" = "$last_dir" ] && continue
            last_dir=$rar_dir
            unrarred_lock=$rar_dir/.$rar_file.unrarred
            [ -e "$unrarred_lock" ] && continue

            sfv_file=${rar_file%.*}.sfv
            if [ 1 = "$HAS_CKSFV" ] && [ -e "$rar_dir/$sfv_file" ]; then
                if ! cksfv -qg "$rar_dir/$sfv_file"; then
                    touch "$unrarred_lock"
                    warn "Invalid RAR: ${rar_dir##$WATCH_DIR/}/$rar_file\n"
                    continue
                fi
            fi

            touch "$unrarred_lock"

            if ! unrar x -inul -y -p- -o+ -r "$rar_dir/$rar_file" "$rar_dir"
            then
                warn "Unable to extract RAR: ${rar_dir##$WATCH_DIR/}/$rar_file\n"
                continue
            fi

            log "Unrarred %s/%s\n" "${rar_dir##$WATCH_DIR/}" "$rar_file"
        done
        break
    done

    [ Finished = "$state" ] || continue

    # Remove each of the RAR files listed in the torrent.
    if [ "$unrarred_lock" ]; then
        count=0
        remote --torrent "$hash" --files |
        while IFS=' ' read -r _ _ _ _ _ _ file; do
            # Skip header lines
            [ $count -lt 2 ] && count=$((count+1)) && continue
            case $file in
                *.rar | *.sfv | *.r[0-9] | *.r[0-9][0-9] | \
                *.r[0-9][0-9][0-9])
                    file_dir=$dir/${file%/*}
                    # Verify directory is valid and in expected location.
                    real_dir "$file_dir" && file_dir=$_real_dir || file_dir=
                    case $file_dir in
                        $WATCH_DIR) ;; $WATCH_DIR/*) ;; *) continue
                    esac
                    rm -f "$dir/$file"
            esac
        done
        log "Removed RAR archive: $name\n"
    fi

    if [ -d "$dir/$name" ]; then
        ! find "$dir/$name" -type f \(                                    \
            -name '*.[Nn][Ff][Oo]' -o -name '.message' -o                 \
            -name '*.part' -o -name '.*.unrarred' -o                      \
            -name '*.nfo' -o -name 'ST.txt' -o                            \
            -name '[Tt]orrent[ _.][Dd]ownloaded[ _.][Ff]rom[ _.]*.txt' -o \
            -name '.DS_Store' -o -name '.localized'                       \
            \) -exec rm -f {} + 2>/dev/null
        ! find "$dir/$name/" -type d -depth \
            -name [Ss][Aa][Mm][Pp][Ll][Ee]  \
            -exec rm -rf {} + 2>/dev/null
    fi

    # Remove empty directories.
    ! find "$WATCH_DIR" -type d -depth -exec rmdir {} + 2>/dev/null

    # Mark files a different color in Finder to indicate they are
    # finished seeding and can safely be deleted.
    if [ 1 = "$HAS_SETLABEL" ]; then
        ! find "$dir/$name" -exec setlabel -s Red {} + 2>/dev/null
    fi

    remote --torrent "$hash" --remove >/dev/null
    log "Removed torrent: $name\n"
done
