#!/bin/sh

# This script is meant to be run from cron. It:
#   - finds torrents under a directory (including its subdirectories) and
#     adds them to transmission, specifying the directory from where the
#     torrent was located to be the completed directory for the data
#   - deselects sample files
#   - throttles public torrents
#   - removes certain "bad" trackers from torrents
#   - removes completed, stopped torrents
#   - verifies RAR archives with cksfv
#   - unrars RAR archives
#   - removes RAR archives after torrent has been removed
#
# TODO:
#   - use getopts to accept command-line options
#   - kill transmission if it's hanging so it can be restarted by some
#     external process (launchd, inetd, etc.)

VERBOSE=1
LOCK=/tmp/transmission-watchdog.lock
NETRC=~/.netrc
WATCH_DIR=~/Media/.
PUBLIC_UP_RATE=2
PUBLIC_RATIO=0

set -o errexit
set -o nounset

IFS=$(printf "\n\t")

has_cmd () { command -v "$@" >/dev/null 2>&1; }
warn    () { printf "$@" >&2; }

if has_cmd flock; then
    flock -nx "$LOCK" || exit
elif has_cmd shlock; then
    trap 'rm -f "$LOCK"; exit' HUP INT QUIT TERM
    shlock -f "$LOCK" -p $$ || exit
    trap 'rm -f "$LOCK"; exit' EXIT
elif has_cmd lockfile; then
    trap 'rm -f "$LOCK"; exit' HUP INT QUIT TERM
    lockfile -r 0 -l 300 "$LOCK" >/dev/null 2>&1 || exit
    trap 'rm -f "$LOCK"; exit' EXIT
else
    ln -s /dev/null "$LOCK" 2>/dev/null || exit
    trap 'rm -f "$LOCK"; exit' EXIT HUP INT QUIT TERM
fi

timeout () {
    timeout=$1
    shift
    "$@" &
    child_pid=$!
    (
        sleep "$timeout" &
        sleep_pid=$!
        trap 'kill -s TERM $sleep_pid 2>/dev/null; exit 0' TERM
        wait $sleep_pid 2>/dev/null
        kill -s TERM $child_pid 2>/dev/null
        sleep 2
        kill -s KILL $child_pid 2>/dev/null
    ) &
    alarm_pid=$!
    wait $child_pid 2>/dev/null
    status=$?
    kill -s TERM $alarm_pid 2>/dev/null
    return $status
}

remote () {
    # TODO: catch "Couldn't connect to server" error and exit
    # TODO: add retry and kill logic
    timeout 30 transmission-remote -N $NETRC "$@"
}

real_dir () {
    _real_dir=
    cd -P -- "$1" 2>/dev/null && _real_dir=$(pwd -P)
}

real_dir "$WATCH_DIR" && WATCH_DIR=$_real_dir || {
    warn 'WATCH_DIR directory "%s" does not exist\n' "$WATCH_DIR"
    exit -1
}

# Add any new torrent files to transmission.
for file in $(find "$WATCH_DIR" -type f -name '*.torrent' 2>/dev/null); do
    dir=${file%/*}

    # Parse the debug output.
    # Use the torrent hash because the ids are not persistent across sessions.
    response=$(
        remote --debug --add "$file" --download-dir "$dir" 2>&1 | \
        awk '/^{"arguments":{.*?"result":/ {x=$0}; END{print x}'
    )

    case "$response" in
        '{"arguments":{"torrent-added":{"hashString":'*)
            SAVED_IFS=$IFS; IFS='"';
            set -- $response; hash=$8;
            IFS=$SAVED_IFS
            rm -f "$file" ;;
        '{"arguments":{},"result":"duplicate torrent"'*)
            warn "Skipping already added torrent: $file\n"
            rm -f "$file"
            continue ;;
        *)
            warn "Failed to add torrent: $file\n"
            mv -f "$file" "$file.failed"
            continue ;;
    esac

    for line in $(remote --torrent "$hash" --info); do
        case "$line" in
            '  Public torrent: '?*) public=${line#*: } ;;
            '  Name: '?*)           name=${line#*: }   ;;
        esac
    done

    [ 1 = "$VERBOSE" ] && printf "Added torrent: $name\n"

    # Deselect sample files.
    ids=$(
        remote --torrent "$hash" --files | \
        sed -n 's/^ *\([0-9]\{1,\}\):.*\/[Ss][Aa][Mm][Pp][Ll][Ee]\/.*/\1/p' | \
        paste -d ',' -s -
    )
    [ "$ids" ] && remote --torrent "$hash" --no-get "$ids" >/dev/null

    for line in $(remote --torrent "$hash" --info-trackers); do
        case "$line" in
            '  Tracker #'*': tracker.openbittorrent.com'* | \
            '  Tracker #'*': tracker.publicbt.'*          | \
            '  Tracker #'*': '*'tracker.prq.to'*          | \
            '  Tracker #'*': '*'h33t.com'*                | \
            '  Tracker #'*': '*'mvgroup.org'*             | \
            '  Tracker #'*': inferno.demonoid.com'*)
                force_public=1 ;;
            '  Tracker #'*': '*'thepiratebay.org'*        | \
            '  Tracker #'*': '*'hexagon.cc'*              | \
            '  Tracker #'*': '*'.onion'*                  | \
            '  Tracker #'*': '*'.tor2web.com'*)
                id=${line#*#}; id=${id%%:*}
                remote --torrent "$hash" --tracker-remove "$id" >/dev/null ;;
        esac
    done

    # Throttle public torrents.
    if [ Yes = "$public" ] || [ 1 = "${force_public-0}" ]; then
        remote --torrent "$hash" --uplimit "$PUBLIC_UP_RATE" \
            --seedratio "$PUBLIC_RATIO" >/dev/null
        [ 1 = "$VERBOSE" ] && printf "Throttled public torrent: $name\n"
    fi
done

has_cmd unrar && HAS_UNRAR=1 || HAS_UNRAR=0
has_cmd cksfv && HAS_CKSFV=1 || HAS_CKSFV=0

for line in $(remote --torrent all --info); do
    val=${line#*: }
    case "$line" in
        '  Hash: '?*)         hash=$val    ;;
        '  Name: '?*)         name=$val    ;;
        '  State: '?*)        state=$val   ;;
        '  Location: '?*)     dir=$val     ;;
        '  Percent Done: '?*) percent=$val
                              do=1         ;;
    esac

    [ 1 != "${do-0}" ] && continue || do=0

    case "$state" in
        Verifying*) continue ;;
    esac

    [ '100%' != "$percent" ] && continue

    last_dir=; unrarred_lock=

    if [ 1 = "$HAS_UNRAR" ]; then
        # Verify directory is valid and in expected location.
        real_dir "$dir" && dir=$_real_dir
        case $dir in
            $WATCH_DIR) ;; $WATCH_DIR/*) ;; *) continue ;;
        esac

        for file in $(find "$dir/$name" -type f -name '*.rar' 2>/dev/null)
        do
            rar_dir=${file%/*}
            rar_file=${file##*/}
            [ "$rar_dir" = "$last_dir" ] && continue
            last_dir=$rar_dir
            unrarred_lock=$rar_dir/.$rar_file.unrarred
            [ -e "$unrarred_lock" ] && continue

            sfv_file=${rar_file%.*}.sfv
            if [ 1 = "$HAS_CKSFV" ] && [ -e "$rar_dir/$sfv_file" ]; then
                if ! nice -n 15 cksfv -qg "$rar_dir/$sfv_file"; then
                    touch "$unrarred_lock"
                    if [ 1 = "$VERBOSE" ]; then
                        warn "Invalid RAR: ${rar_dir##$WATCH_DIR/}/$rar_file\n"
                    fi
                    continue
                fi
            fi

            touch "$unrarred_lock"

            if ! nice -n 15 unrar x -inul -y -p- -o+ -r \
                "$rar_dir/$rar_file" "$rar_dir"
            then
                warn "Unable to extract RAR: ${rar_dir##$WATCH_DIR/}/$rar_file\n"
                continue
            fi

            if [ 1 = "$VERBOSE" ]; then
                printf "Unrarred %s/%s\n" "${rar_dir##$WATCH_DIR/}" "$rar_file"
            fi
        done
    fi

    if [ Finished = "$state" ]; then
        remote --torrent "$hash" --remove >/dev/null
        [ 1 = "$VERBOSE" ] && printf "Removed torrent: $name\n"

        if [ "$unrarred_lock" ]; then
            if [ -d "$dir/$name" ]; then
                ! find "$dir/$name" -type f \( -name '*.rar' -o    \
                    -name '*.r[0-9]' -o -name '*.r[0-9][0-9]' -o   \
                    -name '*.r[0-9][0-9][0-9]' -o -name '*.sfv' -o \
                    -name '*.[Nn][Ff][Oo]' -o -name '.message' -o  \
                    -name '*.part' -o -name '.*.unrarred' -o       \
                    -name 'www.TorrentDay.com.txt' -o              \
                    -name '.DS_Store' -o -name '.localized' \)     \
                    -exec rm -f {} \; 2>/dev/null
                ! find "$dir/$name/" -type d -depth                \
                    -name [Ss][Aa][Mm][Pp][Ll][Ee]                 \
                    -exec rm -rf {} \; 2>/dev/null
                ! find "$dir/$name" -type d -depth                 \
                    -exec rmdir {} \; 2>/dev/null
            elif [ -f "$dir/$name" ]; then
                [ rar = "${file##*.}" ] && rm -f "$dir/$name"
                rm -f "$unrarred_lock"
            fi
            [ 1 = "$VERBOSE" ] && printf "Removed RAR archive: $name\n"
        fi
    fi
done
